var(c(2, 8, 10, 14, 14, 22, 27, 41, 45, 48))
sd(c(2, 8, 10, 14, 14, 22, 27, 41, 45, 48))
dat <- c(2, 8, 10, 14, 14, 22, 27, 41, 45, 48))
dat <- c(2, 8, 10, 14, 14, 22, 27, 41, 45, 48)
dat
mean(dat)
sum((dat - mean(dat))^2)
sum((dat - mean(dat))^2)/9
install.packages("Rcmdr")
devtools::install_github(c("hadley/testthat", "rstudio/shiny", "rstudio/ggvis"))
library(ggvis)
ggvis(mtcars, props(x = ~wt, y = ~mpg)) + mark_point()
ggvis(mtcars, props(x = ~wt, y = ~mpg)) +
layer_smooth(se = TRUE,
span = input_slider(min = 0.3, max = 1, value = 0.8, step = 0.1,
label = "Smoothing span")) +
layer_point() +
guide_axis("x", title = "Weight") +
guide_axis("y", title = "MPG")
ggvis(mtcars, props(x = ~wt)) +
layer_density(
adjust = input_slider(.1, 2, value = 1, step = .1, label = "Bandwidth adjustment"),
kernel = input_select(
c("Gaussian" = "gaussian",
"Epanechnikov" = "epanechnikov",
"Rectangular" = "rectangular",
"Triangular" = "triangular",
"Biweight" = "biweight",
"Cosine" = "cosine",
"Optcosine" = "optcosine"),
label = "Kernel")
)
ggvis(mtcars, props(x = ~wt, y = ~mpg)) +
layer_smooth(span = input_slider(0.5, 1, 1, label = "span")) +
layer_point(props(size := input_slider(100, 1000, label = "size")))
ggvis(mtcars, props(x = ~wt, y = ~mpg, size := input_slider(10, 1000, label = "size"))) +
layer_point(props(fill := "red")) +
layer_point(props(stroke := "black", fill := NA))
qt(.025, 10)
qt(.05, 10)
qt(.05, 15)
qt(.10, 15)
set.seed(7)
shp <- 1 #weibull shape parameter
ns1 <- 1000 #group 1 sample size
ns2 <- 1000 #group 2 sample size
crr1 <- 0 #group 1 event time correlation
crr2 <- 0 #group 2 event time correlation
pcens <- 0 #proportion that will be censored
hr11 <- 1 #group 1 event 1 hazard
hr12 <- 1 #group 1 event 2 hazard
hr21 <- 2 #group 2 event 1 hazard
hr22 <- 2 #group 2 event 2 hazard
#draw event times from weibull distribution
v11 <- matrix(1/hr11*(-log(1-runif(ns1)))^(1/shp),ns1,1) #group 1 event 1
v12 <- matrix(1/hr12*(-log(1-runif(ns1)))^(1/shp),ns1,1) #group 1 event 2
v11
v12
v1 <- cbind(v11,v12) #combine group 1 event times
v21 <- matrix(1/hr21*(-log(1-runif(ns2)))^(1/shp),ns2,1) #group 2 event 1
v22 <- matrix(1/hr22*(-log(1-runif(ns2)))^(1/shp),ns2,1) #group 2 event 2
#used for testing, equivalent to v21, v22 calculations above
#v21 <- rweibull(ns2,shape=shp,scale=1/hr21)
#v22 <- rweibull(ns2,shape=shp,scale=1/hr22)
v2 <- cbind(v21,v22) #combine group 2 event times
e0t <- matrix((-log(1-runif(ns1+ns2)))^(1/shp),ns1+ns2,1)#
nrow(e0t)
rand1 <- matrix(runif(ns1+ns2),ns1+ns2,1)
head(rand1)
gp <- factor(c(matrix(1,ns1,1),matrix(2,ns2,1)),1:2,c(1,2)) #create treatment groups
str(gp)
gp
matrix(1,ns1,1)
c(matrix(1,ns1,1),matrix(2,ns2,1))
library(knitr)
setwd("/home/brandon/Copy/lebebr01.github.io/Rmd")
knit("2014-04-02-aerapreview.Rmd")
